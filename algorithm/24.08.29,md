# 24.08.29

# SW 문제 해결

## SW 문제 해결

### SW문제 해결 역량이란 무엇인가?

- 프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력
- 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력이라 할 수 있다.
- 문제 해결 역량은 추상적인 기술이다.
    - 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체가 없다.
    - 무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않는다.
- 문제 해결 역량을 향상시키기 위해서 훈련이 필요하다.

### 문제 해결 과정

1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어를 재정의한다.
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

### 리스트에 숫자 넣기

- 수 N을 입력 받는다.
- 윗 줄에는 N부터 1씩 증가되는 숫자 4개 왼쪽에 채운다.
- 아랫 줄에는 N부터 1씩 감소되는 숫자 4개 오른쪽에 채운다.
- 최종 결과를 출력한다. 빈공간은 0으로 출력한다.

https://github.com/user-attachments/assets/da7ca598-b5b6-429b-a745-5d989b76a2ef

### 설계 예시

- 2x7 크기의 0으로 채운 리스트를 준비한다.
- 수 N을 입력 받는다.
- t1 = N 대입 후, for 4번 돌려 T1값을 리스트에 넣는다. range(0,4)
- t2 = N 대입 후, for 4번 돌려 T2값을 리스트에 넣는다. range(6,2,-1)
- 리스트 출력

https://github.com/user-attachments/assets/639c83ec-0d3e-4b56-8f7c-79982459cee9

## [정리]SW 문제 해결

### SW문제 해결 능력을 기르는 이유

- 코딩을 더 잘하게 하는 능력을 기르기 위함
- SWEA 문제를 통해 기본문법 & 자료구조 & 알고리즘을 더 능숙하게 쓸 수 있도록 훈련한다.

### SWEA 문제를 잘 풀기 위한 전략

- 단계 1: 완벽한 문제 이해
- 단계 2: 종이와 펜을 이용한 설계하기 (어떻게 구현할지 계획하기
- 단계 3: 설계 한대로 구현 & 디버깅을 한다.

## 복잡도 분석

### 알고리즘:

- 알고리즘: 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다. 주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.
- 어떤 문제를 해결하기 위한 절차
- 예를 들어 1부터 100까지의 합을 구하는 문제를 생각해보자

https://github.com/user-attachments/assets/04ce97f7-e69f-474b-8e0e-c86c68d0fc63

### 알고리즘의 효율

- 공간적 효율성과 시간적 효율성
    - 공간적 효율성은 연산량 대비 얼마나 적은 메모리 공간을 요하는 가를 말한다.
    - 시간적 효율성은 연산량 대비 얼마나 적은 시간을 요하는 가를 말한다.
    - 효율성을 뒤집어 표현하면 복잡도가 된다. 복잡도가 높을수록 효율성은 저하된다.

### 복잡도의 점근적 표기

- 시간 (또는 공간)복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러 개의 항을 가지는 다항식이다.
- 이를 단순한 함수로 표현하기 위해 점근적 표기를 사용한다.
- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.
    - O(Big-Oh) - 표기          → 최대 시간
    - Ω(Big-Omega) - 표기   → 최소 시간
    - Θ(BIg-Theta) - 표기      → 평균 시간

### O(Big-Oh) - 표기

- O-표기는 복잡도의 점근적 상한을 나타낸다.
- 복잡도가 f(n)=2n^2-7n+4이라면, f(n)의 O-표기는 O(n^2)이다.
- 먼저 f(n)의 단순화된 표현은 n^2이다.
- 단순화된 함수 n^2에 임의의 상수 c를 곱한 cn^2이 n이 증가함에 따라 f(n)의 상한이 된다.

https://github.com/user-attachments/assets/1dc9a2ec-f58d-42b7-822d-04710ceefef5

### 빅오표기법을 이렇게 표현하기도 합니다!

- O(5N)
    - 5배수 강조해서 표현하고 싶을 때, O(N)이라고 적지 않고, O(5N)이라고 적곤 합니다.

### 자주 사용하는 O-표기

O(1)        상수 시간

O(logn)   로그(대수) 시간

O(n)        선형시간

O(nlogn) 로그 선형 시간

O(n^2)    제곱 시간

O(n^3)    세제곱 시간

O(logN)은 O(1)보다는 느리지만, 유사한 성능을 보인다고 결론을 낼 수 있다.

O(NlogN)은 O(N)보다는 느리지만, 유사한 성능을 보인다고 결론을 낼 수 있다.

## [정리] 복잡도 분석

### 왜 효율적인 알고리즘이 필요한가

- 10억 개의 숫자를 정렬하는데 PC에서 O(n^2) 알고리즘은 300여 년이 걸리는 반면에 O(nlogn) 알고리즘은 5분만에 정렬한다.

https://github.com/user-attachments/assets/091ae722-3e59-4e67-82e2-d73630833584

- 효율적인 알고리즘은 슈퍼 컴퓨터보다 더 큰 가치가 있다.
- 값 비싼 H/W 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적이다.

## 진수 (진법)

### 2진수, 8진수, 10진수, 16진수

- 10진수: 사람이 사용하는 진수, 수 하나를 0~9로 표현
- 2진수: 컴퓨터 사용하는 진수, 수 하나를 0,1로 표현
- 16진수: 2진수를 더 가독성 있게 사용, 수하나를 0,1…9,A,B,C,D,E,F로 표현

### 용어 암기

- HEX: 16진수
- DEC: 10진수
- OCT: 8진수
- BIN: 2진수